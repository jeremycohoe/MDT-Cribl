# Formatting Data

Once your data is being sent from telegraf to cribl, you'll notice it is a deeply embedded JSON schema with multiple arrays. This makes it very challenging to work with. We want to break our data apart so we can format it the way we want to display it. Here is a truncated example of model-driven-telemetry for a single interface on a virtual router:

```
[{"instrumentation_library":{"name":"unknown","version":"unknown"},"metrics":[{"name":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics_in_octets","description":"","unit":"","data":{"data_points":[{"attributes":{"host":"f054a84bef4c","name":"GigabitEthernet2","path":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics","source":"hq-rtr2","subscription":"201"},"time_unix_nano":1700263526562000000,"exemplars":[],"value":88761353}]},"__type":"gauge"},
{"name":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics_num_flaps","description":"","unit":"","data":{"data_points":[{"attributes":{"source":"hq-rtr2","subscription":"201","host":"f054a84bef4c","name":"GigabitEthernet2","path":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics"},"time_unix_nano":1700263526562000000,"exemplars":[],"value":0}]},"__type":"gauge"},
{"name":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics_out_multicast_pkts","description":"","unit":"","data":{"data_points":[{"attributes":{"name":"GigabitEthernet2","path":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics","source":"hq-rtr2","subscription":"201","host":"f054a84bef4c"},"time_unix_nano":1700263526562000000,"exemplars":[],"value":0}]},"__type":"gauge"},{"name":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics_out_discards","description":"","unit":"","data":{"data_points":[{"attributes":{"host":"f054a84bef4c","name":"GigabitEthernet2","path":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics","source":"hq-rtr2","subscription":"201"},"time_unix_nano":1700263526562000000,"exemplars":[],"value":0}]},"__type":"gauge"},
{"name":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics_rx_kbps","description":"","unit":"","data":{"data_points":[{"attributes":{"path":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics","source":"hq-rtr2","subscription":"201","host":"f054a84bef4c","name":"GigabitEthernet2"},"time_unix_nano":1700263526562000000,"exemplars":[],"value":0}]},"__type":"gauge"},{"name":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics_in_unicast_pkts","description":"","unit":"","data":{"data_points":[{"attributes":{"host":"f054a84bef4c","name":"GigabitEthernet2","path":"Cisco-IOS-XE-interfaces-oper:interfaces/interface/statistics","source":"hq-rtr2","subscription":"201"},"time_unix_nano":1700263526562000000,"exemplars":[],"value":894614}]},"__type":"gauge"},
```
The usable data is deep inside of the schema. What we really want is the source (device name), description of the metric (for example statistics_rx_kbps), and the value of that metric. The challenge is with the embedded nature of the arrays where each of these peices of data live. This is why using a standard parser doesn't work because you need to loop through the array to extract what you need. So how do we deal with this data? 




